// GARY
/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡤⠶⠒⠛⠛⠛⠛⠓⠒⠢⢤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠚⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠢⣄⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⡠⠞⠁⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⢀⡴⠊⠁⠀⠀⠀⠈⠙⠢⣀⠀⠀⠀⠀⠀⢀⠴⠊⠁⠀⠀⠀⠉⠑⢤⡀⠀
⠀⠀⠀⠀⠀⡠⠊⠀⠀⠀⢰⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣱⠋⠀⠀⠀⠀⠀⡠⠂⠁⠢⡈⢢⠀⠀⠀⢠⠃⠀⠀⠀⠀⠀⠎⢁⡈⢢⠱⡄
⠀⠀⠀⢀⠞⠁⠀⠀⠀⠀⠈⠛⠻⠟⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⠀⠀⠀⠀⠀⡁⢰⣿⡆⢱⠀⡆⠀⠀⡇⠀⠀⠀⠀⠀⠘⡀⠸⠿⢠⠀⢳
⠀⠀⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠣⣀⠉⣁⠏⠀⡇⠀⠘⡇⠀⠀⠀⠀⠀⠀⠑⠠⠄⠊⠀⣸
⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣾⣷⣦⠀⠀⠀⠀⠀⠀⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⢰⠃⠀⠀⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃
⠀⡞⠀⠀⢠⣶⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠘⢦⡀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠃⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⣀⠴⠁⠀
⢰⠃⠀⠀⢺⣿⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⠿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⠦⣤⣤⣤⠤⠖⣿⠀⠀⠀⠀⠀⠀⠀⠀⠉⣿⠓⠒⢺⠏⠁⠀⠀⠀
⣾⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⢀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⡄⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⢸⠀⠀⠀⠀⠀
⡿⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⢳⡀⠀⠸⡆⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⣿⠀⠀⠀⠀⠀
⡇⠀⢰⣿⣿⡆⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡄⢧⠀⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⡇⠀⠀⠀⠀⠀
⣷⠀⠸⣿⣿⡇⠀⢠⣿⣿⡿⠋⠉⠙⠻⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⢸⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⢸⠇⠘⡆⠀⢻⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⢸⡇⠀⠀⠀⠀⠀
⢹⠀⠀⠈⠉⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠘⢿⣿⣿⠀⠀⠀⠀⠀⠀⠀⣼⠀⠀⢱⠀⠸⡆⠀⠀⠀⠀⠀⠀⠀⢸⠀⢸⠀⠀⠀⠀⠀⠀
⠸⡆⠀⠀⠀⠀⠀⢸⣿⣷⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠈⠙⠁⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠈⡇⠀⣷⠀⠀⠀⠀⠀⠀⠀⣿⠀⣼⠀⠀⠀⠀⠀⠀
⠀⢷⠀⠀⠀⠀⠀⠸⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⢿⠀⢸⡀⠀⠀⠀⠀⠀⠀⡏⠀⡿⠀⠀⠀⠀⠀⠀
⠀⠘⣇⠀⠀⠀⠀⠀⢿⣿⣧⣀⣠⣧⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⢸⡄⠈⣇⠀⠀⠀⠀⠀⠀⡇⠀⡇⠀⠀⠀⠀⠀⠀
⠀⠀⠹⡆⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⡇⠀⠀⠀⢸⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⠀⠘⡇⠀⢻⠀⠀⠀⠀⠀⠀⡇⢠⡇⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠻⣿⣿⡿⠃⠀⠀⠀⠀⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⣿⠀⠸⡇⠀⠀⠀⠀⢰⠁⢸⠇⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡇⠀⠀⠀⠀⠀⢿⠀⠀⣷⠀⠀⠀⠀⢸⠀⢸⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠁⠀⠀⠀⠀⠀⢸⠀⠀⠸⡄⠀⠀⠀⡾⠀⢸⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠻⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠤⣄⠀⠀⠀⠀⢸⠀⠀⠀⢱⠀⠀⠀⡇⠀⢸⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠙⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣆⠀⠀⢸⠀⠀⠀⠀⢇⠀⢰⠃⠀⢸⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⠒⠋⠉⠙⠛⠛⠒⠊⠋⠀⠀⠀⠀⠈⠲⠾⠶⠦⢼⣄⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢘⡶⠴⠶⠒⠒⠒⠒⠒⠺⠿⠿⣿⣿⣁⣀⣀⠀⠀⠀⣀⣠⠴⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⣦⡀⠀⠀⠀
⠀⠀⠀⠀⣴⡋⠉⠉⠉⠙⠦⣤⣀⣀⣀⣀⣀⣀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⢀⣀⣠⠤⠔⠒⠚⠉⠉⠉⠉⠒⠒⠤⠤⠤⠤⠤⠄⠂⠁⠈⠛⠒⢶⠄
⠀⠀⠀⠀⠉⠛⠒⠒⠺⣦⣀⡀⣀⣀⣀⣀⠀⠀⠀⠉⠉⠁⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⠤⣀⣀⣠⠖⠁⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠙⠻⠶⢤⣤⡤⠤⠶⠖⠛⠉⠛⠷⠶⠶⠖⠛⠋⠉⠛⠳⢦⣤⣤⡤⠤⠒⠒⠛⠛⠶⠶⠖⠒⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀
*/

// include libraries
#include "Wire.h" // for I2C
#include "Adafruit_MPRLS.h" // pressure sensor
#include "PID_v2.h" // Include PID Library: https://github.com/imax9000/Arduino-PID-Library

double atmosphere = 14.63;

// multiplexer setup
#define TCAADDR 0x70 // define multiplexer I2C address
// to select multiplexer output
void tcaselect(uint8_t i) {
  if (i > 7) return;
 
  Wire.beginTransmission(TCAADDR);
  Wire.write(1 << i);
  Wire.endTransmission();  
}

// Relay connection/signal pins
#define Solenoid1 24 // 3-way
#define Solenoid2 22 // 3-way
#define Solenoid3 46 // 3-way
#define Solenoid4 44 // 3-way
#define Solenoid5 42 // 3-way
#define Solenoid6 40 // 3-way
#define Solenoid7 38 // 3-way
#define Solenoid8 32 // 2-way
#define Solenoid9 30 // 2-way
#define Solenoid10 28 // 2-way
#define Solenoid11 26 // 2-way
#define Solenoid12 48 // 2-way

// Switch connection pins
#define SW1 43
#define SW2 41
#define SW3 39
#define SW4 37
#define SW5 35
#define SW6 31
#define SW7 29
#define SW8 47
#define SW9 27
#define SW10 25
#define SW11 23
#define SW12 45
#define SWAuto 33 // to switch between manual and automated code
#define buttonNext 53 // to advance to next step
#define readyLED 7 // to indicate if ready to advance to next step

// pump PID pin
#define pumpPin 10

// pressure sensor setup
#define RESET_PIN -1 // set to any GPIO pin # to hard-reset on begin()
#define EOC_PIN -1 // set to any GPIO pin to read end-of-conversion by pin
// create pressure sensor objects
Adafruit_MPRLS mpr0 = Adafruit_MPRLS(RESET_PIN, EOC_PIN);
Adafruit_MPRLS mpr1 = Adafruit_MPRLS(RESET_PIN, EOC_PIN);
Adafruit_MPRLS mpr2 = Adafruit_MPRLS(RESET_PIN, EOC_PIN);
Adafruit_MPRLS mpr3 = Adafruit_MPRLS(RESET_PIN, EOC_PIN);
Adafruit_MPRLS mpr4 = Adafruit_MPRLS(RESET_PIN, EOC_PIN);
Adafruit_MPRLS mpr5 = Adafruit_MPRLS(RESET_PIN, EOC_PIN);
Adafruit_MPRLS mpr6 = Adafruit_MPRLS(RESET_PIN, EOC_PIN);
Adafruit_MPRLS mpr7 = Adafruit_MPRLS(RESET_PIN, EOC_PIN);
// create variables to store pressure sensor values 
double pressure0;
double pressure1;
double pressure2;
double pressure3;
double pressure4;
double pressure5;
double pressure6;
double pressure7;

// state machine variables
unsigned long currentMillis;
unsigned long previousMillis = 0;
#define numStates 17 // = number of states
bool autoNext = false; // auto advance to next step

const unsigned long default_delay = 10;
unsigned long period_ms = default_delay;

int pressureState = 0;
bool autoState = false;
bool promptAsked = false;
bool buttonPressed = false;
int stateCounter = 1;

bool pumpState = false; // for pump bang bang control

// user input FSM
bool state = 0;
int ps = 0, ns = 0;

// auto pressure method variables
bool pressureNext = false;
double pumpTarget;

// PID loop setup
double aggKp = 20, aggKi = 50, aggKd = 10;
double consKp = aggKp/10, consKi = aggKi/10, consKd = aggKd/10;
double PIDOutput;
double gapThreshold = 0.25;
double PIDGap;
const unsigned int PIDSampleTime = 100;
double setpoint = 1.5;
PID_v2 PressurePID (consKp, consKi, consKd, PID::Direct); // create PID object

void setup() {
  // change valve PWM pin frequencies
  TCCR2B = TCCR2B & B11111000 | B00000001;  // for PWM frequency of 31372.55 Hz on 9 and 10
  // TCCR3B = TCCR3B & B11111000 | B00000001;  // for PWM frequency of 31372.55 Hz on 2, 3, and 5
  // TCCR4B = TCCR4B & B11111000 | B00000001;  // for PWM frequency of 31372.55 Hz on 6, 7, and 8

  // I2C and Serial setup
  Wire.begin(); // I2C
  Serial.begin(9600);
  Serial1.begin(9600);

  // scan for I2C devices
  I2Cscan();

  // check if all 8 sensors are initialized
  sensorInitialization();

  // initialize relay pins
  pinMode(Solenoid1, OUTPUT);
  pinMode(Solenoid2, OUTPUT);
  pinMode(Solenoid3, OUTPUT);
  pinMode(Solenoid4, OUTPUT);
  pinMode(Solenoid5, OUTPUT);
  pinMode(Solenoid6, OUTPUT);
  pinMode(Solenoid7, OUTPUT);
  pinMode(Solenoid8, OUTPUT);
  pinMode(Solenoid9, OUTPUT);
  pinMode(Solenoid10, OUTPUT);
  pinMode(Solenoid11, OUTPUT);
  pinMode(Solenoid12, OUTPUT);
  pinMode(50, OUTPUT); // unused relay
  pinMode(52, OUTPUT); // unused relay
  pinMode(34, OUTPUT); // unused relay
  pinMode(36, OUTPUT); // unused relay

  // initialize ready LED
  pinMode(readyLED, OUTPUT);

  // initialize Switch pins
  pinMode(SW1, INPUT);
  pinMode(SW2, INPUT);
  pinMode(SW3, INPUT);
  pinMode(SW4, INPUT);
  pinMode(SW5, INPUT);
  pinMode(SW6, INPUT);
  pinMode(SW7, INPUT);
  pinMode(SW8, INPUT);
  pinMode(SW9, INPUT);
  pinMode(SW10, INPUT);
  pinMode(SW11, INPUT);
  pinMode(SW12, INPUT);
  pinMode(SWAuto, INPUT);
  pinMode(buttonNext, INPUT);

  // turn off all relay pins (HIGH = off) by default
  digitalWrite(Solenoid1, HIGH);
  digitalWrite(Solenoid2, HIGH);
  digitalWrite(Solenoid3, HIGH);
  digitalWrite(Solenoid4, HIGH);
  digitalWrite(Solenoid5, HIGH);
  digitalWrite(Solenoid6, HIGH);
  digitalWrite(Solenoid7, HIGH);
  digitalWrite(Solenoid8, HIGH);
  digitalWrite(Solenoid9, HIGH);
  digitalWrite(Solenoid10, HIGH);
  digitalWrite(Solenoid11, HIGH);
  digitalWrite(Solenoid12, HIGH);
  digitalWrite(50, HIGH); // unused relay
  digitalWrite(52, HIGH); // unused relay
  digitalWrite(34, HIGH); // unused relay
  digitalWrite(36, HIGH); // unused relay

  // setup PID loop
  PressurePID.SetSampleTime(PIDSampleTime);
  PressurePID.Start(pressure0, PIDOutput, setpoint); // input, output, setpoint
}

void loop() {
  currentMillis = millis(); // update millis

  userInput(); // update user input FSM

  // pressure read
  pressureRead();
  
  // pump control
  // analogWrite(pumpPin, 255); // always on
  // pumpBangBang (1.4, 1.6);
  PIDOutput = pumpPID(pressure0); // PID control on pump pressure
  analogWrite(pumpPin, PIDOutput); // PWM output

  pressureNext = autoPressure(stateCounter); // check pressures to determine eligibility to move to next step

  if (digitalRead(SWAuto) && (stateCounter <= (numStates + 1))) { // automatic code
    if (currentMillis - previousMillis >= period_ms) {
      if (!promptAsked) {
        Serial.print("Press button to begin state #");
        Serial.println(stateCounter);
        promptAsked = true;
        // pumpTarget = pressure0; // store target pressure
      }
      if (state || autoNext) {
        period_ms = solenoidActions(stateCounter);
        stateCounter++; // increment state
        promptAsked = false;
        previousMillis = currentMillis; // reset millis counter
      }
      if (pressureNext) {
        digitalWrite(readyLED, HIGH); // turn ready LED on
      } else {
        digitalWrite(readyLED, LOW); // turn ready LED off
      }
    } else {
      digitalWrite(readyLED, LOW); // turn ready LED off
    }

    if (stateCounter == 5) {
      PressurePID.Setpoint(setpoint/2);
    } else {
      PressurePID.Setpoint(setpoint);
    }
  } else { // manual code
    solenoidManual(); // update solenoids according to switches
    digitalWrite(readyLED, LOW); // turn ready LED off
    stateCounter = 1;
  }
}

// to scan for I2C devices connected to the multiplexer
void I2Cscan() {
  Serial.println("\nTCAScanner ready!");
  for (uint8_t t=0; t<8; t++) {
    tcaselect(t);
    Serial.print("TCA Port #"); Serial.println(t);

    for (uint8_t addr = 0; addr<=127; addr++) {
      if (addr == TCAADDR) continue;

      Wire.beginTransmission(addr);
      if (!Wire.endTransmission()) {
        Serial.print("Found I2C 0x");  Serial.println(addr,HEX);
      }
    }
  }
  Serial.println("\ndone");
}

// check if all 8 sensors are connected and initialized
void sensorInitialization() {
  tcaselect(0);
  if (!mpr0.begin()) {
    Serial.println("MPRLS sensor 0 failed");
  } else {
  Serial.println("Found MPRLS sensor 0");
  }

  tcaselect(1);
  if (!mpr1.begin()) {
    Serial.println("MPRLS sensor 1 failed");
  } else {
  Serial.println("Found MPRLS sensor 1");
  }

  tcaselect(2);
  if (!mpr2.begin()) {
    Serial.println("MPRLS sensor 2 failed");
  } else {
  Serial.println("Found MPRLS sensor 2");
  }

  tcaselect(3);
  if (!mpr3.begin()) {
    Serial.println("MPRLS sensor 3 failed");
  } else {
  Serial.println("Found MPRLS sensor 3");
  }

  tcaselect(4);
  if (!mpr4.begin()) {
    Serial.println("MPRLS sensor 4 failed");
  } else {
  Serial.println("Found MPRLS sensor 4");
  }

  tcaselect(5);
  if (!mpr5.begin()) {
    Serial.println("MPRLS sensor 5 failed");
  } else {
  Serial.println("Found MPRLS sensor 5");
  }

  tcaselect(6);
  if (!mpr6.begin()) {
    Serial.println("MPRLS sensor 6 failed");
  } else {
  Serial.println("Found MPRLS sensor 6");
  }

  tcaselect(7);
  if (!mpr7.begin()) {
    Serial.println("MPRLS sensor 7 failed");
  } else {
  Serial.println("Found MPRLS sensor 7");
  }
}

// Controls ports
void portControl(int port, int state) {
  // Implementation:
  // LOW = solenoid on/vac
  // HIGH = solenoid off/vent
  // cases execute in order
  // number after return statement is delay for that step

  // NOTE: 11 is linked to 2
  // blocked = 11 HIGH, 2 HIGH
  // vent = 11 LOW, 2 HIGH
  // vac = 11 LOW, 2 LOW

  // NOTE: 8 is linked to 4
  // blocked = 8 HIGH, 4 HIGH
  // vent = 8 LOW, 4 HIGH
  // vac = 8 LOW, 4 LOW

  // digitalWrite(Solenoid1, HIGH/LOW); // vent/vac -> 1 (port 1)
  // digitalWrite(Solenoid2, HIGH/LOW); // vent/vac -> 2 (port 2)
  // digitalWrite(Solenoid3, HIGH/LOW); // vent/vac -> 3 (port 3)
  // digitalWrite(Solenoid4, HIGH/LOW); // vent/vac -> 4 (port 4)
  // digitalWrite(Solenoid5, HIGH/LOW); // vent/vac -> 5 (port 5)
  // digitalWrite(Solenoid6, HIGH/LOW); // vent/vac -> 6 (port 6)
  // digitalWrite(Solenoid7, HIGH/LOW); // vent/vac -> 7 (port 7)
  // digitalWrite(Solenoid8, HIGH/LOW); // blocked/open -> 8 (port 4)
  // digitalWrite(Solenoid9, HIGH/LOW); // blocked/open -> 9 (port 8)
  // digitalWrite(Solenoid10, HIGH/LOW); // blocked/open -> 10 (port 9)
  // digitalWrite(Solenoid11, HIGH/LOW); // blocked/open -> 11 (port 2)
  // digitalWrite(Solenoid12, HIGH/LOW); // blocked/open -> 12 (port 10)

  // States:
  // 3-way
  // 1 -> vent
  // 2 -> vac

  // 2-way
  // 1 -> blocked
  // 2 -> vent

  // joint
  // 1 -> blocked
  // 2 -> vent
  // 3 -> vac
  switch (port) {
    case 1: // 3-way
      if (state == 1) { // vent
        digitalWrite(Solenoid1, HIGH);
      } else if (state == 2) { // vac
        digitalWrite(Solenoid1, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid1, HIGH);
      }
    break;

    case 2: // joint
      if (state == 1) { // blocked
        digitalWrite(Solenoid2, HIGH);
        digitalWrite(Solenoid11, HIGH);
      } else if (state == 2) { // vent
        digitalWrite(Solenoid2, HIGH);
        digitalWrite(Solenoid11, LOW);
      } else if (state == 3) { // vac
        digitalWrite(Solenoid2, LOW);
        digitalWrite(Solenoid11, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid2, HIGH);
        digitalWrite(Solenoid11, HIGH);
      }
    break;

    case 3: // 3-way
      if (state == 1) { // vent
        digitalWrite(Solenoid3, HIGH);
      } else if (state == 2) { // vac
        digitalWrite(Solenoid3, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid3, HIGH);
      }
    break;

    case 4: // joint
      if (state == 1) { // blocked
        digitalWrite(Solenoid4, HIGH);
        digitalWrite(Solenoid8, HIGH);
      } else if (state == 2) { // vent
        digitalWrite(Solenoid4, HIGH);
        digitalWrite(Solenoid8, LOW);
      } else if (state == 3) { // vac
        digitalWrite(Solenoid4, LOW);
        digitalWrite(Solenoid8, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid4, HIGH);
        digitalWrite(Solenoid8, HIGH);
      }
    break;

    case 5: // 3-way
      if (state == 1) { // vent
        digitalWrite(Solenoid5, HIGH);
      } else if (state == 2) { // vac
        digitalWrite(Solenoid5, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid5, HIGH);
      }
    break;

    case 6: // 3-way
      if (state == 1) { // vent
        digitalWrite(Solenoid6, HIGH);
      } else if (state == 2) { // vac
        digitalWrite(Solenoid6, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid6, HIGH);
      }
    break;

    case 7: // 3-way
      if (state == 1) { // vent
        digitalWrite(Solenoid7, HIGH);
      } else if (state == 2) { // vac
        digitalWrite(Solenoid7, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid7, HIGH);
      }
    break;

    case 8: // 2-way
      if (state == 1) { // blocked
        digitalWrite(Solenoid9, HIGH);
      } else if (state == 2) { // vent
        digitalWrite(Solenoid9, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid9, HIGH);
      }
    break;

    case 9: // 2-way
      if (state == 1) { // blocked
        digitalWrite(Solenoid10, HIGH);
      } else if (state == 2) { // vent
        digitalWrite(Solenoid10, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid10, HIGH);
      }
    break;

    case 10: // 2-way
      if (state == 1) { // blocked
        digitalWrite(Solenoid12, HIGH);
      } else if (state == 2) { // vent
        digitalWrite(Solenoid12, LOW);
      } else { // invalid state num
        Serial.println("INVALID STATE");
        digitalWrite(Solenoid12, HIGH);
      }
    break;

    default:
      // by default, do action: turn all off
      digitalWrite(Solenoid1, HIGH);
      digitalWrite(Solenoid2, HIGH);
      digitalWrite(Solenoid3, HIGH);
      digitalWrite(Solenoid4, HIGH);
      digitalWrite(Solenoid5, HIGH);
      digitalWrite(Solenoid6, HIGH);
      digitalWrite(Solenoid7, HIGH);
      digitalWrite(Solenoid8, HIGH);
      digitalWrite(Solenoid8, HIGH);
      digitalWrite(Solenoid9, HIGH);
      digitalWrite(Solenoid10, HIGH);
      digitalWrite(Solenoid11, HIGH);
      digitalWrite(Solenoid12, HIGH);
    break;
  }
}

// semi-automated solenoid control
long solenoidActions(int stateNumber) {
  // intro line
  Serial.println(); // blank line
  Serial.println("/////////////////");
  Serial.print("Beginning State #");
  Serial.println(stateNumber);

  switch (stateNumber) {
    case 1:
      // do action: turn all off, message, delay 0.5s
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 1); // blocked
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 1); // blocked
      Serial.println("Press button to begin.");
      autoNext = false;
      return default_delay;
    break;

    case 2:
      // do action: vent port 8 and 9, delay 0.5s, message
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 1); // blocked
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 2); // vent
      portControl(9, 2); // vent
      portControl(10, 1); // blocked
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 3:
      // do action: vac port 1, delay 0.5s, message
      portControl(1, 2); // vac
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 1); // blocked
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 2); // vent
      portControl(9, 2); // vent
      portControl(10, 1); // blocked
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 4:
      // do action: vac port 2, delay 0.5s, message
      portControl(1, 2); // vac
      portControl(2, 3); // vac
      portControl(3, 1); // vent
      portControl(4, 1); // blocked
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 2); // vent
      portControl(9, 2); // vent
      portControl(10, 1); // blocked
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 5:
      // do action: block port 8, vent port 4, block port 2, delay 0.5s, message
      portControl(1, 2); // vac
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 2); // vent
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 2); // vent
      portControl(10, 1); // blocked
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 6:
      // do action: vac port 3, delay 0.25s, go to next step
      portControl(1, 2); // vac
      portControl(2, 1); // blocked
      portControl(3, 2); // vac
      portControl(4, 2); // vent
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 2); // vent
      portControl(10, 1); // blocked
      autoNext = true;
      return 250;
    break;

    case 7:
      // do action: vac port 5, delay 0.5s, message
      portControl(1, 2); // vac
      portControl(2, 1); // blocked
      portControl(3, 2); // vac
      portControl(4, 2); // vent
      portControl(5, 2); // vac
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 2); // vent
      portControl(10, 1); // blocked
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 8:
      // do action: vent port 10, block port 9, delay 0.5s, message
      portControl(1, 2); // vac
      portControl(2, 1); // blocked
      portControl(3, 2); // vac
      portControl(4, 2); // vent
      portControl(5, 2); // vac
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 9:
      // do action: vent port 3 and 5, delay 0.5s, message
      portControl(1, 2); // vac
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 2); // vent
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 10:
      // do action: vac port 6, delay 0.5s, message
      portControl(1, 2); // vac
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 2); // vent
      portControl(5, 1); // vent
      portControl(6, 2); // vac
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 11:
      // do action: vent port 1, delay 0.5s, go to next step
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 2); // vent
      portControl(5, 1); // vent
      portControl(6, 2); // vac
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      autoNext = true;
      return 500;
    break;

    case 12:
      // do action: vac port 4, delay 0.5s, message
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 3); // vac
      portControl(5, 1); // vent
      portControl(6, 2); // vac
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 13:
      // do action: vac port 7, delay 0.5s, message
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 3); // vac
      portControl(5, 1); // vent
      portControl(6, 2); // vac
      portControl(7, 2); // vac
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 14:
      // do action: vent port 6, delay 0.5s, message
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 3); // vac
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 2); // vac
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 15:
      // do action: block port 10, delay 0.5s, message
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 3); // vac
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 2); // vac
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 1); // blocked
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 16:
      // do action: vent port 10, delay 0.5s, message
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 3); // vac
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 2); // vac
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      Serial.println("Press button to");
      autoNext = false;
      return default_delay;
    break;

    case 17:
      // do action: vac port 6, delay 0.5s, message
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 3); // vac
      portControl(5, 1); // vent
      portControl(6, 2); // vac
      portControl(7, 2); // vac
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 2); // vent
      Serial.println("Workflow complete!");
      Serial.println("//////////////////");
      Serial.println();
      autoNext = false;
      return default_delay;
    break;

    default:
      // by default, do action: turn all off
      portControl(1, 1); // vent
      portControl(2, 1); // blocked
      portControl(3, 1); // vent
      portControl(4, 1); // blocked
      portControl(5, 1); // vent
      portControl(6, 1); // vent
      portControl(7, 1); // vent
      portControl(8, 1); // blocked
      portControl(9, 1); // blocked
      portControl(10, 1); // blocked
      autoNext = false;
      return default_delay;
    break;
  }
}

// control solenoids according to switches
void solenoidManual() {
  if (digitalRead(SW1)) {
    digitalWrite(Solenoid1, HIGH);
  } else {
    digitalWrite(Solenoid1, LOW);
    // Serial.println("Solenoid 1 on");
  }

  if (digitalRead(SW2)) {
    digitalWrite(Solenoid2, HIGH);
    // Serial.println("Solenoid 2 on");
  } else {
    digitalWrite(Solenoid2, LOW);
  }

  if (digitalRead(SW3)) {
    digitalWrite(Solenoid3, HIGH);
    // Serial.println("Solenoid 3 on");
  } else {
    digitalWrite(Solenoid3, LOW);
  }

  if (digitalRead(SW4)) {
    digitalWrite(Solenoid4, HIGH);
    // Serial.println("Solenoid 4 on");
  } else {
    digitalWrite(Solenoid4, LOW);
  }

  if (digitalRead(SW5)) {
    digitalWrite(Solenoid5, HIGH);
    // Serial.println("Solenoid 5 on");
  } else {
    digitalWrite(Solenoid5, LOW);
  }

  if (digitalRead(SW6)) {
    digitalWrite(Solenoid6, HIGH);
    // Serial.println("Solenoid 6 on");
  } else {
    digitalWrite(Solenoid6, LOW);
  }

  if (digitalRead(SW7)) {
    digitalWrite(Solenoid7, HIGH);
    // Serial.println("Solenoid 7 on");
  } else {
    digitalWrite(Solenoid7, LOW);
  }

  if (digitalRead(SW8)) {
    digitalWrite(Solenoid8, HIGH);
    // Serial.println("Solenoid 8 on");
  } else {
    digitalWrite(Solenoid8, LOW);
  }

  if (digitalRead(SW9)) {
    digitalWrite(Solenoid9, HIGH);
    // Serial.println("Solenoid 9 on");
  } else {
    digitalWrite(Solenoid9, LOW);
  }

  if (digitalRead(SW10)) {
    digitalWrite(Solenoid10, HIGH);
    // Serial.println("Solenoid 10 on");
  } else {
    digitalWrite(Solenoid10, LOW);
  }

  if (digitalRead(SW11)) {
    digitalWrite(Solenoid11, HIGH);
    // Serial.println("Solenoid 11 on");
  } else {
    digitalWrite(Solenoid11, LOW);
  }

  if (digitalRead(SW12)) {
    digitalWrite(Solenoid12, HIGH);
    // Serial.println("Solenoid 12 on");
  } else {
    digitalWrite(Solenoid12, LOW);
  }
}

// turn pump fully on or fully off in order to keep it between two setpoints
void pumpBangBang(float lower, float upper) {  
  // keep pressure in accumulator between threshold values
  if (pumpState == false && pressure0 < lower) { // if pump is off and pressure is below lower limit, turn pump on
    pumpState = true;
  } else if (pumpState == true && pressure0 > upper) { // if pump is on and pressure rises above upper limit, turn pump off
    pumpState = false;
  }

  if (pumpState) {
    analogWrite(pumpPin, 255); // enable pump
  } else {
    analogWrite(pumpPin, 0); // disable pump
  }
}

double pumpPID(double input) {
  // adaptive tuning
  PIDGap = abs(PressurePID.GetSetpoint() - input);  // distance away from setpoint

  if (PIDGap < gapThreshold) {
    // if close to setpoint, use conservative tuning parameters
    PressurePID.SetTunings(consKp, consKi, consKd);
  } else {
    // if far from setpoint, use aggressive tuning parameters
    PressurePID.SetTunings(aggKp, aggKi, aggKd);
  }
  
  return PressurePID.Run(input); // compute PID output
}

// read pressure on all MPRLS sensors
void pressureRead() {
  // read from pressure sensors
  tcaselect(0); // select multiplexer output
  pressure0 = mpr0.readPressure() / 68.947572932; // read pressure, convert to PSI

  tcaselect(1); // select multiplexer output
  pressure1 = mpr1.readPressure() / 68.947572932; // read pressure, convert to PSI

  tcaselect(2); // select multiplexer output
  pressure2 = mpr2.readPressure() / 68.947572932; // read pressure, convert to PSI

  tcaselect(3); // select multiplexer output
  pressure3 = mpr3.readPressure() / 68.947572932; // read pressure, convert to PSI

  tcaselect(4); // select multiplexer output
  pressure4 = mpr4.readPressure() / 68.947572932; // read pressure, convert to PSI

  tcaselect(5); // select multiplexer output
  pressure5 = mpr5.readPressure() / 68.947572932; // read pressure, convert to PSI

  tcaselect(6); // select multiplexer output
  pressure6 = mpr6.readPressure() / 68.947572932; // read pressure, convert to PSI

  tcaselect(7); // select multiplexer output
  pressure7 = mpr7.readPressure() / 68.947572932; // read pressure, convert to PSI

  // convert absolute to relative pressure
  pressure0 = atmosphere - pressure0;
  pressure1 = atmosphere - pressure1;
  pressure2 = atmosphere - pressure2;
  pressure3 = atmosphere - pressure3;
  pressure4 = atmosphere - pressure4;
  pressure5 = atmosphere - pressure5;
  pressure6 = atmosphere - pressure6;
  pressure7 = atmosphere - pressure7;
  
  // print pressures to serial monitor/plotter
  Serial1.print(pressure0);
  Serial1.print(",");
  Serial1.print(pressure1);
  Serial1.print(",");
  Serial1.print(pressure2);
  Serial1.print(",");
  Serial1.print(pressure3);
  Serial1.print(",");
  Serial1.print(pressure4);
  Serial1.print(",");
  Serial1.print(pressure5);
  Serial1.print(",");
  Serial1.print(pressure6);
  Serial1.print(",");
  Serial1.print(pressure7);
  Serial1.print(",");

  // plot button pulse on serial channel 9
  if (digitalRead(buttonNext)) {
    Serial1.println(1);    
  } else {
    Serial1.println(0);
  }
}

// user input FSM
void userInput() {
  switch (ps) {
    case 0:
      if (digitalRead(buttonNext)) {
        ns = 1;
      } else {
        ns = 0;
      }  
    break;

    case 1:
      ns = 2;
    break;

    case 2:
      if (!digitalRead(buttonNext)) {
        ns = 0;
      } else {
        ns = 2;
      }
    break;

    default:
      ns = 0;
    break;
  }

  if (ps == 1) {
    state = 1;
  } else {
    state = 0;
  }

  // present state = next state
  ps = ns;
}

// check if pressures are at desired value, if so, return true
bool autoPressure(int stateNum) {
  pumpTarget = 0.95*setpoint;
  
  switch (stateNum) { 
    case 4:
      return (pressure1 >= pumpTarget);
    break;

    case 8:
      return ((pressure3 >= pumpTarget) && (pressure5 >= pumpTarget));
    break;

    case 11:
      return (pressure6 >= pumpTarget);
    break;

    case 14:
      return (pressure7 >= pumpTarget);
    break;

    default: // in all other cases, always return true
      return true;
    break;
  }
}